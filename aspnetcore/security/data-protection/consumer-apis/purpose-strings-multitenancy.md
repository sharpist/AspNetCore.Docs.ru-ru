---
title: Иерархия целей и мультитенантность в ASP.NET Core
author: rick-anderson
description: Сведения об иерархии строк назначения и использовании многофакторной связи, так как она относится к ASP.NET Core интерфейсам API защиты данных.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 65799c10b8e810853023c094b95ccafa0d71eb8b
ms.sourcegitcommit: 65add17f74a29a647d812b04517e46cbc78258f9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "88632087"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a>Иерархия целей и мультитенантность в ASP.NET Core

Так как объект `IDataProtector` также неявно является `IDataProtectionProvider` , цели могут быть объединены в цепочку. В этом смысле `provider.CreateProtector([ "purpose1", "purpose2" ])` эквивалентно `provider.CreateProtector("purpose1").CreateProtector("purpose2")` .

Это позволяет некоторым интересным иерархическим связям через систему защиты данных. В предыдущем примере для [contoso. Messaging. секуремессаже](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose)компонент секуремессаже может вызываться `provider.CreateProtector("Contoso.Messaging.SecureMessage")` один раз перед передним планом и кэшировать результат в закрытое `_myProvider` поле. Затем можно создавать будущие предохранители с помощью вызовов `_myProvider.CreateProtector("User: username")` , а эти предохранители будут использоваться для защиты отдельных сообщений.

Это также можно сделать зеркально. Рассмотрим единое логическое приложение, в котором размещается несколько клиентов (это кажется разумным), и каждый клиент может быть настроен с помощью собственной системы проверки подлинности и управления состоянием. Приложение-шаблон имеет одного главного поставщика и вызывает `provider.CreateProtector("Tenant 1")` и, `provider.CreateProtector("Tenant 2")` чтобы предоставить каждому клиенту собственный изолированный срез системы защиты данных. Клиенты могут получить собственные индивидуальные предохранители, основываясь на их собственных нуждах, но независимо от того, насколько сложно они попытаются, не могут создавать предохранители, которые конфликтуют с любым другим клиентом в системе. Графическое представление представлено ниже.

![Многопользовательские цели](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> Предполагается, что приложение-клиент управляет тем, какие интерфейсы API доступны отдельным клиентам, и что клиенты не могут выполнять произвольный код на сервере. Если клиент может выполнять произвольный код, он может выполнить закрытое отражение, чтобы разбить гарантии изоляции, или просто прочитать материал главного ключа напрямую и получить все необходимые им подразделы.

Система защиты данных в действительности использует сортировку по умолчанию в стандартной конфигурации. По умолчанию материал основного ключа хранится в папке профиля пользователя учетной записи рабочего процесса (или в реестре для удостоверений пула приложений IIS). Но на самом деле довольно часто используется одна учетная запись для запуска нескольких приложений, и поэтому все эти приложения будут совместно использовать главный материал для ключа. Для решения этой проблемы система защиты данных автоматически вставляет уникальный идентификатор приложения в качестве первого элемента в цепочке общего назначения. Это неявное назначение позволяет [изолировать отдельные приложения](xref:security/data-protection/configuration/overview#per-application-isolation) друг от друга, эффективно рассматривая каждое приложение как уникальный клиент в системе, и процесс создания предохранителя будет аналогичен приведенному выше изображению.
