---
title: Снять защиту с полезных данных, ключи которых были отозваны в ASP.NET Core
author: rick-anderson
description: Узнайте, как снять защиту данных, защищенных с помощью ключей, которые были отозваны в ASP.NET Core приложении.
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
no-loc:
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/consumer-apis/dangerous-unprotect
ms.openlocfilehash: a0b5bb29c509e8cc999b998776da3ab4ec27ec29
ms.sourcegitcommit: d65a027e78bf0b83727f975235a18863e685d902
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2020
ms.locfileid: "85408400"
---
# <a name="unprotect-payloads-whose-keys-have-been-revoked-in-aspnet-core"></a>Снять защиту с полезных данных, ключи которых были отозваны в ASP.NET Core

<a name="data-protection-consumer-apis-dangerous-unprotect"></a>

ASP.NET Core API-интерфейсы защиты данных в основном не предназначены для неопределенного сохранения конфиденциальных полезных данных. Другие технологии, такие как [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) и [Azure Rights Management](/rights-management/) , более подходят для сценария неопределенного хранилища и имеют соответствующие возможности управления ключами. С другой стороны, разработчик не запрещает использовать ASP.NET Core API-интерфейсы защиты данных для долгосрочной защиты конфиденциальных данных. Ключи никогда не удаляются из кольца ключей, поэтому `IDataProtector.Unprotect` всегда могут восстанавливать существующие полезные данные, если ключи доступны и действительны.

Однако проблема возникает, когда разработчик пытается снять защиту с данных, защищенных с помощью отозванного ключа, так как `IDataProtector.Unprotect` в этом случае будет выдано исключение. Это может быть удобно для кратковременных или временных полезных данных (например, маркеров проверки подлинности), так как эти типы полезных данных могут легко воссоздаться системой, и в худшем случае посетителям сайта может потребоваться снова войти в систему. Но для сохраненных полезных данных использование `Unprotect` throw может привести к неприемлемой потери данных.

## <a name="ipersisteddataprotector"></a>иперсистеддатапротектор

Для поддержки сценария, позволяющего снять защиту полезных данных даже в случае отозванных ключей, система защиты данных содержит `IPersistedDataProtector` тип. Чтобы получить экземпляр `IPersistedDataProtector` , просто получите экземпляр `IDataProtector` обычным образом и попробуйте приведение `IDataProtector` к `IPersistedDataProtector` .

> [!NOTE]
> Не все `IDataProtector` экземпляры могут быть приведены к `IPersistedDataProtector` . Разработчики должны использовать оператор C# AS или аналогичный, чтобы избежать исключений среды выполнения, вызванных недопустимыми приведениями, и должны быть готовы к обработке случайного сбоя.

`IPersistedDataProtector`предоставляет следующую поверхность API:

```csharp
DangerousUnprotect(byte[] protectedData, bool ignoreRevocationErrors,
     out bool requiresMigration, out bool wasRevoked) : byte[]
```

Этот API принимает защищенные полезные данные (в виде массива байтов) и возвращает незащищенные полезные данные. Перегрузка на основе строк отсутствует. Ниже приведены два выходных параметра.

* `requiresMigration`: будет иметь значение true, если ключ, используемый для защиты этих полезных данных, больше не является активным ключом по умолчанию, например, ключ, используемый для защиты этой полезной нагрузки, устарел и операция с предыдущим ключом уже выполнена. Вызывающий объект может попытаться повторно защитить полезные данные в зависимости от бизнес-потребностей.

* `wasRevoked`: будет иметь значение true, если ключ, используемый для защиты полезной нагрузки, был отозван.

>[!WARNING]
> При передаче `ignoreRevocationErrors: true` в метод Будьте предельно осторожны `DangerousUnprotect` . Если после вызова этого метода `wasRevoked` значение равно true, то ключ, используемый для защиты этих полезных данных, был отозван, а подлинность полезной нагрузки должна рассматриваться как подозрительная. В этом случае продолжайте работать только с незащищенными полезными данными, только если у вас есть отдельная гарантия, которую она подлинна, например, она поступает из защищенной базы данных, а не отправляется недоверенным веб-клиентом.

[!code-csharp[](dangerous-unprotect/samples/dangerous-unprotect.cs)]
