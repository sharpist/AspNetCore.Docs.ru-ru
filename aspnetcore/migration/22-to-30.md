---
title: Миграция с ASP.NET Core 2,2 на 3,0
author: rick-anderson
description: Узнайте, как перенести проект ASP.NET Core 2,2 в ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 8868bce9bd7e5cb1b6f4b6040ec7c83b6394538f
ms.sourcegitcommit: 497be502426e9d90bb7d0401b1b9f74b6a384682
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/08/2020
ms.locfileid: "88015313"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Миграция с ASP.NET Core 2,2 на 3,0

[Скотт Эдди (](https://github.com/scottaddie) и [Рик Андерсон (](https://twitter.com/RickAndMSFT)

В этой статье объясняется, как обновить существующий проект ASP.NET Core 2,2 до ASP.NET Core 3,0. Может оказаться полезным создать новый проект ASP.NET Core 3,0, чтобы:

* Сравните с кодом ASP.NET Core 2,2.
* Скопируйте соответствующие изменения в проект ASP.NET Core 3,0.

## <a name="prerequisites"></a>Предварительные требования

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio для Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Обновление версии пакета SDK для .NET Core в файле global.json

Если решение полагается на [global.js](/dotnet/core/tools/global-json) файла для конкретной версии пакет SDK для .NET Core, обновите ее `version` свойство до версии 3,0, установленной на компьютере:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Обновление файла проекта

### <a name="update-the-target-framework"></a>Обновление целевой платформы

ASP.NET Core 3,0 и более поздних версий работают только в .NET Core. Задайте для [моникера целевой платформы (TFM)](/dotnet/standard/frameworks) значение `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Удалить устаревшие ссылки на пакеты

Для ASP.NET Core 3,0 не создается большое количество пакетов NuGet. Такие ссылки на пакеты должны быть удалены из файла проекта. Рассмотрим следующий файл проекта для веб-приложения ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Обновленный файл проекта для ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Обновленный файл проекта ASP.NET Core 3,0:

* В `<PropertyGroup>`:
  * Обновляет TFM до`netcoreapp3.0`
  * Удаляет `<AspNetCoreHostingModel>` элемент. Дополнительные сведения см. [в разделе внутрипроцессного размещения модели](#in-process-hosting-model) в этом документе.

* В `<ItemGroup>`:
  * `Microsoft.AspNetCore.App`удаляется. Дополнительные сведения см. в [справочнике по платформе](#framework-reference) в этом документе.
  * `Microsoft.AspNetCore.Razor.Design`удаляется, и в следующем списке пакетов больше не создается.

Чтобы просмотреть полный список пакетов, которые больше не создаются, выберите следующий список развертывания:

<details>
    <summary>Щелкните, чтобы развернуть список пакетов, которые больше не создаются</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft. AspNetCore. Authentication. Cookie #d0</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft. AspNetCore. Cookie Политик</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft. AspNetCore. MVC. Razor . ViewCompilation</li>
        <li>Microsoft. AspNetCore. MVC. Razor См</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. AspNetCore.Razor</li>
        <li>Microsoft. AspNetCore. Razor . Этапе</li>
        <li>Microsoft. AspNetCore. Razor . Разработка</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore. SignalR . Центральный</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Проверка критических изменений

[Проверка критических изменений](#break)

### <a name="framework-reference"></a>Справочник по платформе

Функции ASP.NET Core, которые были доступны в одном из перечисленных выше пакетов, доступны в составе `Microsoft.AspNetCore.App` общей платформы. *Общая платформа* — это набор сборок (*DLL*-файлы), которые установлены на компьютере, содержащий компонент среды выполнения и целевой пакет. Дополнительную информацию см. в этой публикации об [общей платформе](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Проекты, предназначенные для пакета SDK `Microsoft.NET.Sdk.Web`, неявно ссылаются на платформу `Microsoft.AspNetCore.App`.

  Для этих проектов не требуются дополнительные ссылки:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Для проектов, предназначенных `Microsoft.NET.Sdk` `Microsoft.NET.Sdk.Razor` для или для пакета SDK, следует добавить явный `FrameworkReference` к `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Сборки, зависящие от платформы, с помощью DOCKER

Зависящие от платформы сборки консольных приложений, использующих пакет, который зависит от ASP.NET Core [общей платформы](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) , может предоставить следующую ошибку времени выполнения:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`— Это общая платформа, содержащая среду выполнения ASP.NET Core и которая имеется только в образе DOCKER, который является [DotNet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) . Пакет SDK 3,0 уменьшает размер сборок, зависящих от платформы, с помощью ASP.NET Core, не включая дублированные копии библиотек, доступных в общей платформе. Это может привести к экономии до 18 МБ, но для запуска приложения необходимо, чтобы среда выполнения ASP.NET Core присутствовала или была установлена.

Чтобы определить, имеет ли приложение зависимость (прямая или косвенная) на ASP.NET Core общей платформе, изучите *runtimeconfig.jsв* файле, созданном во время сборки или публикации приложения. В следующем JSON-файле показана зависимость от ASP.NET Core общей платформы:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Если приложение использует DOCKER, используйте базовый образ, включающий ASP.NET Core 3,0. Например, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Добавление ссылок на пакеты для удаленных сборок

ASP.NET Core 3,0 удаляет некоторые сборки, которые ранее были частью `Microsoft.AspNetCore.App` ссылки на пакет. Чтобы визуализировать, какие сборки были удалены, Сравните две папки общей платформы. Например, Сравнение версий 2.2.7 и 3.0.0:

![Сравнение сборок общей платформы](22-to-30/_static/assembly-diff.png)

Чтобы продолжить использование функций, предоставляемых удаленными сборками, сослаться на версии 3,0 соответствующих пакетов:

* Веб-приложение, созданное шаблоном с **отдельными учетными записями пользователей** , требует добавления следующих пакетов:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Дополнительные сведения об обращении к пакету для конкретного поставщика базы данных см. в разделе [поставщики баз данных](/ef/core/providers/index).

* Пользовательский интерфейс Identity

  Поддержку [ Identity пользовательского интерфейса](xref:security/authentication/identity) можно добавить, обратившись к [Microsoft. AspNetCore. Identity Пакет пользовательского интерфейса](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Службы SPA

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices);
  * [Microsoft. AspNetCore. Спасервицес. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Проверка подлинности. Поддержка сторонних потоков аутентификации доступна в виде пакетов NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Проверка подлинности учетной записи Майкрософт ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Проверка подлинности OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Токен носителя OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Проверка подлинности WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Поддержка форматирования и согласования содержимого для `System.Net.HttpClient` : пакет NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) предоставляет полезную расширяемость для `System.Net.HttpClient` интерфейсов API, таких как `ReadAsAsync` и `PostJsonAsync` .

* Razorкомпиляция среды выполнения: поддержка компиляции Razor представлений и страниц в среде выполнения теперь является частью [Microsoft. AspNetCore. MVC. Razor Рунтимекомпилатион](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* `Newtonsoft.Json`Поддержка MVC (JSON.NET): поддержка использования MVC с `Newtonsoft.Json` теперь является частью [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>Изменения при запуске

На следующем рисунке показаны удаленные и измененные строки в Razor веб-приложении ASP.NET Core 2,2 Pages:

![Удаленные и измененные строки в ASP.NET Core 2,2::: No-Loc (Razor)::: Web App](22-to-30/_static/startup2.2.png)

На предыдущем рисунке удаленный код показан красным цветом. Удаленный код не отображает cookie код параметров, который был удален до сравнения файлов.

На следующем рисунке показаны добавленные и измененные строки в Razor веб-приложении ASP.NET Core 3,0 Pages:

![добавленные и измененные строки в ASP.NET Core 3,0::: No-Loc (Razor)::: Web App](22-to-30/_static/startup3.0.png)

На предыдущем рисунке добавлен код, показанный зеленым цветом. Сведения о следующих изменениях:

* `services.AddMvc`в `services.AddRazorPages` см. раздел [Регистрация службы MVC](#mvc-service-registration) в этом документе.
* `CompatibilityVersion`, см <xref:mvc/compatibility-version> . раздел.
* `IHostingEnvironment``IWebHostEnvironment`сведения см. в [этом объявлении GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`был добавлен в шаблоны для отображения промежуточного слоя авторизации заказа. Если приложение не использует авторизацию, можно безопасно удалить вызов `app.UseAuthorization` .
* `app.UseEndpoints`см. в разделе [ Razor pages](#razor-pages) или [Migrate Startup.Configключать](#migrate-startupconfigure) в этом документе.

### <a name="analyzer-support"></a>Поддержка анализатора

Проекты, предназначенные для `Microsoft.NET.Sdk.Web` неявной ссылки на анализаторы, ранее поставляемые в составе пакета [Microsoft. AspNetCore. MVC. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Для включения этих дополнительных ссылок не требуется.

Если приложение использует [анализаторы API](xref:web-api/advanced/analyzers) , которые ранее поставлялись с пакетом [Microsoft. AspNetCore. MVC. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , измените файл проекта, чтобы он ссылался на анализаторы, поставляемые в составе веб-пакета SDK .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="no-locrazor-class-library"></a>RazorБиблиотека классов

RazorПроекты библиотеки классов, предоставляющие компоненты пользовательского интерфейса для MVC, должны задавать `AddRazorSupportForMvc` свойство в файле проекта:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Модель внутрипроцессного размещения

По умолчанию в проектах используется [модель внутрипроцессного размещения](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) в ASP.NET Core 3,0 или более поздней версии. При необходимости вы можете удалить `<AspNetCoreHostingModel>` свойство в файле проекта, если его значение равно `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Конфигурация

Миграция конфигурации Kestrel в [построитель веб-узлов](#hostb) , предоставляемый `ConfigureWebHostDefaults` (*Program.CS*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Если приложение создает узел вручную с помощью `HostBuilder` , вызовите `UseKestrel` в построителе веб-узлов в `ConfigureWebHostDefaults` :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>По промежуточного слоя соединения заменяет Адаптеры подключений

Адаптеры подключений ( `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` ) удалены из Kestrel. Замените адаптеры подключений по промежуточного слоя соединения. По промежуточного слоя соединения аналогично по промежуточного слоя HTTP в ASP.NET Core конвейере, но для соединений более низкого уровня. Протокол HTTPS и регистрация подключения:

* Были перемещены из адаптеров соединений в по промежуточного слоя соединения.
* Эти методы расширения работают как в предыдущих версиях ASP.NET Core. 

Дополнительные сведения см. в [примере тлсфилтерконнектионхандлер в разделе листеноптионс. Protocols статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Абстракции транспорта перемещены и сделаны открытыми

Транспортный уровень Kestrel предоставляется как открытый интерфейс в `Connections.Abstractions`. В состав этих обновлений:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`и связанные типы были удалены.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>был перемещен из <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> в параметры транспорта.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`был удален из <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

Дополнительные сведения см. в следующих ресурсах GitHub:

* [Абстракции сети "клиент-сервер" (#10308 DotNet/AspNetCore)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Реализуйте новую абстракцию прослушивателя основой и Plat Kestrel сверху (DotNet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Заголовков анонса запроса Kestrel

Для приложений, предназначенных для более ранних версий ASP.NET Core:

* Kestrel добавляет заголовки поблочного трейлера HTTP/1.1 в коллекцию заголовков запросов.
* Трейлеры доступны после считывания текста запроса в конец.

Это вызывает некоторые проблемы, связанные с неоднозначностью заголовков и трейлеров, поэтому эти трейлеры были перемещены в новую коллекцию ( `RequestTrailerExtensions` ) в 3,0.

Запросы HTTP/2:

* Недоступно в ASP.NET Core 2,2.
* Доступно в 3,0 как `RequestTrailerExtensions` .

Для доступа к этим трейлерам имеются новые методы расширения запроса. Как и в случае с HTTP/1.1, трейлеры доступны после считывания текста запроса в конец.

Для выпуска 3,0 `RequestTrailerExtensions` доступны следующие методы.

* `GetDeclaredTrailers`: Получает заголовок запроса `Trailer` , в котором указывается, какие из этих трейлеров следует рассчитывать после текста.
* `SupportsTrailers`: Указывает, поддерживает ли запрос получение заголовков трейлеров.
* `CheckTrailersAvailable`: Проверяет, поддерживает ли запрос трейлеры и доступны ли они для чтения. Эта проверка не предполагает наличие трейлеров для чтения. Возможно, не существует трейлеров для чтения, даже если `true` он возвращается этим методом.
* `GetTrailer`: Получает запрошенный конечный заголовок из ответа. Проверка `SupportsTrailers` перед вызовом `GetTrailer` или <xref:System.NotSupportedException> может произойти, если запрос не поддерживает конечные заголовки.

Дополнительные сведения см. [в разделе помещение запроса на постановку в отдельную коллекцию (DotNet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Алловсинчронаусио отключена

`AllowSynchronousIO`включает или отключает синхронные API ввода-вывода, такие как `HttpRequest.Body.Read` , `HttpResponse.Body.Write` и `Stream.Flush` . Эти API-интерфейсы являются источником нехватка потоков, ведущих к сбоям приложений. В 3.0 `AllowSynchronousIO` отключен по умолчанию. Дополнительные сведения см. в [разделе синхронный ввод-вывод статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Если требуется синхронный ввод-вывод, его можно включить, настроив `AllowSynchronousIO` параметр на используемом сервере (при вызове `ConfigureKestrel` , например, при использовании Kestrel). Обратите внимание, что у серверов (Kestrel, HttpSys, TestServer и т. д.) есть собственный `AllowSynchronousIO` параметр, который не влияет на другие серверы. Синхронный ввод-вывод можно включить для всех серверов на основе каждого запроса с помощью `IHttpBodyControlFeature.AllowSynchronousIO` параметра:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

При возникновении проблем с <xref:System.IO.TextWriter> реализациями или другими потоками, вызывающими синхронные API-интерфейсы в [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), вызывайте новый <xref:System.IO.Stream.DisposeAsync*> API.

Дополнительные сведения см. [в разделе [объявление] алловсинчронаусио Disabled On All Servers (DotNet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="output-formatter-buffering"></a>Буферизация модуля форматирования выходных данных

[Newtonsoft.Json](https://www.newtonsoft.com/json) <xref:System.Xml.Serialization.XmlSerializer> <xref:System.Runtime.Serialization.DataContractSerializer> Модули форматирования выходных данныхNewtonsoft.Js, и на основе поддерживают только синхронную сериализацию. Чтобы разрешить этим модулям форматирования работать с ограничениями [алловсинчронаусио](https://github.com/dotnet/aspnetcore/issues/7644) сервера, MVC помещает выходные данные модулей форматирования перед записью на диск. В результате буферизации MVC будет включать заголовок Content-Length при ответе с помощью этих модулей форматирования.

<xref:System.Text.Json>поддерживает асинхронную сериализацию, поэтому `System.Text.Json` модуль форматирования на основе не выполняет буферизацию. Рассмотрите возможность использования этого модуля форматирования для повышения производительности.

Чтобы отключить буферизацию, приложения могут настраиваться <xref:Microsoft.AspNetCore.Mvc.MvcOptions.SuppressOutputFormatterBuffering> при запуске.

```csharp
services.AddControllers(options => options.SuppressOutputFormatterBuffering = true)
```

Обратите внимание, что это может привести к возникновению исключения среды выполнения, если оно `AllowSynchronousIO` также не настроено.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Удалена сборка Microsoft. AspNetCore. Server. Kestrel. HTTPS

В ASP.NET Core 2,1 содержимое *Microsoft.AspNetCore.Server.Kestrel.Https.dll* перемещено в *Microsoft.AspNetCore.Server.Kestrel.Core.dll*. Это обновление было не критическое с помощью `TypeForwardedTo` атрибутов. Для 3,0 пустая сборка *Microsoft.AspNetCore.Server.Kestrel.Https.dll* и пакет NuGet удалены.

Библиотеки, ссылающиеся на [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) , должны обновлять зависимости ASP.NET Core до 2,1 или более поздней версии.

Приложения и библиотеки, предназначенные для ASP.NET Core 2,1 или более поздней версии, должны удалять все прямые ссылки на пакет [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Поддержка Newtonsoft.Json (Json.NET)

В рамках работы по [улучшению ASP.NET Core общей платформы](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [Newtonsoft.Json (JSON.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) был удален из ASP.NET Core общей платформы.

Сериализатор JSON по умолчанию для ASP.NET Core теперь является <xref:System.Text.Json> новым в .NET Core 3,0. Рассмотрите возможность использования `System.Text.Json` , когда это возможно. Это высокопроизводительное и не требует дополнительной зависимости библиотеки. Однако поскольку `System.Text.Json` это новая возможность, в настоящее время в ней могут отсутствовать функции, необходимые вашему приложению. Дополнительные сведения см. в разделе [Переход с Newtonsoft.Jsна в System.Text.Js](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-no-locsignalr-project"></a>Использование Newtonsoft.Json в проекте ASP.NET Core 3,0 SignalR

* Установите [Microsoft. AspNetCore. SignalR Пакет NuGet protocols. Невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .

* На клиенте привязать `AddNewtonsoftJsonProtocol` вызов метода к `HubConnectionBuilder` экземпляру:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chathub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* На сервере привязать `AddNewtonsoftJsonProtocol` вызов метода к `AddSignalR` вызову метода в `Startup.ConfigureServices` :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Использование Newtonsoft.Json в проекте MVC ASP.NET Core 3,0

* Установите [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) пакет.

* Обновление `Startup.ConfigureServices` для вызова `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`совместима с новыми методами регистрации службы MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`параметры можно задать в вызове `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Примечание.** Если `AddNewtonsoftJson` метод недоступен, убедитесь, что [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) пакет установлен. Распространенной ошибкой является установка [Newtonsoft.Jsдля](https://www.nuget.org/packages/Newtonsoft.Json/) пакета, а не [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) пакета.

## <a name="mvc-service-registration"></a>Регистрация службы MVC

ASP.NET Core 3,0 добавляет новые параметры для регистрации сценариев MVC в `Startup.ConfigureServices` .

Доступны три новых метода расширения верхнего уровня, относящихся к сценариям MVC `IServiceCollection` . Шаблоны используют эти новые методы вместо `AddMvc` . Тем не менее, `AddMvc` будет работать так же, как в предыдущих выпусках.

В следующем примере добавлена поддержка контроллеров и функций, связанных с API, но не представлений и страниц. Шаблон API использует следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

В следующем примере добавлена поддержка контроллеров, функций, связанных с API, и представлений, но не страниц. В шаблоне веб-приложения (MVC) используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

В следующем примере добавлена поддержка Razor страниц и минимальная поддержка контроллера. В шаблоне веб-приложения используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Новые методы также можно сочетать. Следующий пример эквивалентен вызову `AddMvc` в ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Код запуска маршрутизации

Если приложение вызывает `UseMvc` или `UseSignalR` , перенесите приложение в [маршрутизацию конечной точки](xref:fundamentals/routing) , если это возможно. Чтобы улучшить совместимость маршрутизации конечных точек с предыдущими версиями MVC, мы отправили некоторые изменения в формировании URL-адресов, появившиеся в ASP.NET Core 2,2. Если у вас возникли проблемы с маршрутизацией конечных точек в 2,2, предполагаю, что улучшения ASP.NET Core 3,0, за исключением следующих:

* Если приложение реализует `IRouter` или наследует из `Route` , используйте [динамикраутевалуестрансформер](https://github.com/dotnet/AspNetCore.Docs/issues/12997) в качестве замены.
* Если приложение напрямую обращается в `RouteData.Routers` MVC для анализа URL-адресов, это можно заменить с помощью [Линкпарсер. парсепасбендпоинтнаме](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Определите маршрут с именем маршрута.
  * Используйте `LinkParser.ParsePathByEndpointName` и передайте нужное имя маршрута.

Маршрутизация конечных точек поддерживает тот же синтаксис шаблона маршрута и функции создания шаблона маршрута, что и `IRouter` . Маршрутизация конечных точек поддерживает `IRouteConstraint` . Маршрутизация конечных точек поддерживает `[Route]` , `[HttpGet]` и другие АТРИБУТЫ маршрутизации MVC.

Для большинства приложений требуются только `Startup` изменения.

### <a name="migrate-startupconfigure"></a>Миграция Startup.Configключать

Общие рекомендации:

* Добавьте `UseRouting`.
* Если приложение вызывает `UseStaticFiles` , поместите `UseStaticFiles` **перед** ним `UseRouting` .
* Если приложение использует функции проверки подлинности и авторизации `AuthorizePage` , такие как или `[Authorize]` , поместите вызов `UseAuthentication` и `UseAuthorization` : **After**, `UseRouting` и `UseCors` , но до `UseEndpoints` :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Замените `UseMvc` или `UseSignalR` на `UseEndpoints` .
* Если приложение использует сценарии [CORS](xref:security/cors) , например `[EnableCors]` , поместите вызов `UseCors` до любого другого по промежуточного слоя, использующего CORS (например, поместите `UseCors` перед `UseAuthentication` , `UseAuthorization` и `UseEndpoints` ).
* Замените `IHostingEnvironment` на `IWebHostEnvironment` и добавьте `using` оператор для <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> пространства имен.
* Замените `IApplicationLifetime` на <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).
* Замените `EnvironmentName` на <xref:Microsoft.Extensions.Hosting.Environments> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).

Ниже приведен пример кода `Startup.Configure` в типичном приложении ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

После обновления предыдущего `Startup.Configure` кода выполните следующие действия.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Для большинства приложений вызовы `UseAuthentication` , `UseAuthorization` и `UseCors` должны находиться между вызовами функций `UseRouting` и, `UseEndpoints` чтобы быть эффективными.

### <a name="health-checks"></a>Проверки работоспособности

Для проверок работоспособности используется маршрутизация конечных точек с универсальным узлом. В `Startup.Configure` вызовите `MapHealthChecks` для построителя конечной точки с URL-адресом конечной точки или относительным путем:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Конечные точки проверки работоспособности могут:

* указать один или несколько разрешенных узлов или портов;
* требовать авторизацию;
* требовать CORS.

Для получения дополнительной информации см. <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Руководство по по промежуточного слоя безопасности

Поддержка авторизации и CORS унифицирована на основе подхода по [промежуточного слоя](xref:fundamentals/middleware/index) . Это позволяет использовать одно и то же по промежуточного слоя и функциональные возможности в этих сценариях. В этом выпуске реализовано обновленное по по промежуточного слоя авторизации, а по промежуточного слоя CORS улучшено, чтобы он мог понять, какие атрибуты используются контроллерами MVC.

#### <a name="cors"></a>CORS

Ранее CORS было сложно настроить. По промежуточного слоя было предоставлено для использования в некоторых случаях, но фильтры MVC предназначены для использования **без** по промежуточного слоя в других вариантах использования. В ASP.NET Core 3,0 рекомендуется, чтобы все приложения, требующие CORS, использовали по промежуточного слоя CORS в сочетании с маршрутизацией конечных точек. `UseCors`можно указать с политикой по умолчанию, а `[EnableCors]` `[DisableCors]` атрибуты и можно использовать для переопределения политики по умолчанию, если это необходимо.

В следующем примере:

* CORS включена для всех конечных точек с `default` именованной политикой.
* `MyController`Класс отключает CORS с помощью `[DisableCors]` атрибута.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Авторизация

В более ранних версиях ASP.NET Core Поддержка авторизации была предоставлена с помощью `[Authorize]` атрибута. По промежуточного слоя авторизации недоступно. В ASP.NET Core 3,0 требуется по промежуточного слоя авторизации. Рекомендуется поместить ASP.NET Core по промежуточного слоя авторизации ( `UseAuthorization` ) сразу после `UseAuthentication` . По промежуточного слоя авторизации также можно настроить политику по умолчанию, которую можно переопределить.

В ASP.NET Core 3,0 или более поздней версии `UseAuthorization` вызывается в `Startup.Configure` , а для следующего `HomeController` требуется пользователь, выполнивший вход:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

При использовании маршрутизации конечных точек рекомендуется настроить `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` и, вместо этого, полагаться на по промежуточного слоя авторизации.  Если приложение использует в `AuthorizeFilter` качестве глобального фильтра в MVC, рекомендуется выполнить рефакторинг кода, чтобы предоставить политику в вызове `AddAuthorization` .

`DefaultPolicy`Изначально настраивается для обязательной проверки подлинности, поэтому дополнительная настройка не требуется. В следующем примере конечные точки MVC помечаются как, `RequireAuthorization` так что все запросы должны быть разрешены на основе `DefaultPolicy` . Однако `HomeController` разрешает доступ без входа пользователя в приложение из-за `[AllowAnonymous]` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Авторизация для конкретных конечных точек

Авторизацию также можно настроить для конкретных классов конечных точек. Приведенный ниже код представляет собой пример преобразования приложения MVC, настроенного глобальным `AuthorizeFilter` для приложения, с определенной политикой, для которой требуется авторизация.

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Политики также можно настроить. `DefaultPolicy`Настроена для обязательной проверки подлинности:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Кроме того, для всех конечных точек можно настроить требование авторизации без использования `[Authorize]` или `RequireAuthorization` настройки `FallbackPolicy` . Объект `FallbackPolicy` отличается от `DefaultPolicy` . Триггер активируется `DefaultPolicy` `[Authorize]` или `RequireAuthorization` , а триггер активируется, `FallbackPolicy` когда не задана другая политика. `FallbackPolicy`изначально настроен на разрешение запросов без авторизации.

Следующий пример аналогичен предыдущему `DefaultPolicy` примеру, но использует, `FallbackPolicy` чтобы всегда требовать проверку подлинности для всех конечных точек, за исключением случаев `[AllowAnonymous]` , когда указан параметр.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Авторизация по промежуточного слоя работает без каких бы то ни было конкретных знаний авторизации. Например, [проверки работоспособности](xref:host-and-deploy/health-checks) не имеют определенных знаний авторизации, но проверки работоспособности могут иметь настраиваемую политику авторизации по промежуточного слоя.

Кроме того, каждая конечная точка может настраивать свои требования к авторизации. В следующем примере `UseAuthorization` обрабатывается авторизация с помощью `DefaultPolicy` , но для `/healthz` конечной точки проверки работоспособности требуется `admin` пользователь:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Защита реализована в некоторых сценариях. По промежуточного слоя конечных точек создает исключение, если политика авторизации или CORS пропускается из-за отсутствия по промежуточного слоя. Поддержка анализатора для предоставления дополнительных отзывов о ненастроенном состоянии.

#### <a name="custom-authorization-handlers"></a>Пользовательские обработчики авторизации

Если приложение использует пользовательские [обработчики авторизации](xref:security/authorization/policies#authorization-handlers), то маршрутизация конечных точек передает обработчикам различные типы ресурсов, чем MVC. Обработчики, которые предполагают, что ресурс контекста обработчика авторизации имеет тип <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (тип ресурса, [предоставленный фильтрами MVC](xref:security/authorization/policies#access-mvc-request-context-in-handlers)), должен быть обновлен для обработки ресурсов типа <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (тип ресурса, предоставленный для обработчиков авторизации по маршрутизации конечной точки).

MVC по-прежнему использует `AuthorizationFilterContext` ресурсы, поэтому, если приложение использует фильтры авторизации MVC вместе с авторизацией маршрутизации конечных точек, может потребоваться обрабатывать оба типа ресурсов.

### SignalR

Теперь сопоставление SignalR концентраторов выполняется внутри `UseEndpoints` .

Сопоставьте каждый концентратор с `MapHub` . Как и в предыдущих версиях, каждый концентратор явно указан.

В следующем примере `ChatHub` SignalR добавляется поддержка концентратора:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Существует новый параметр управления ограничениями на размер сообщений от клиентов. Например, для `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

В ASP.NET Core 2,2 можно задать `TransportMaxBufferSize` и, который эффективно управляет максимальным размером сообщения. В ASP.NET Core 3,0 этот параметр теперь позволяет управлять только максимальным размером до подавления нехватки.

### <a name="mvc-controllers"></a>Контроллеры MVC

Теперь сопоставление контроллеров выполняется внутри `UseEndpoints` .

Добавить `MapControllers` , если приложение использует маршрутизацию атрибутов. Так как маршрутизация включает поддержку многих платформ в ASP.NET Core 3,0 или более поздней версии, Добавление контроллеров с маршрутизацией с атрибутами является явным согласием.

Вместо

* `MapRoute` с `MapControllerRoute`
* `MapAreaRoute` с `MapAreaControllerRoute`

Так как маршрутизация теперь включает поддержку не только для MVC, терминология была изменена, чтобы эти методы были четко изменяли то, что они делают. Стандартные маршруты, такие как, `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` применяются в порядке их добавления. Сначала разместите более конкретные маршруты (например, маршруты для области).

В следующем примере:

* `MapControllers`добавляет поддержку контроллеров с маршрутизацией на основе атрибутов.
* `MapAreaControllerRoute`добавляет стандартный маршрут для контроллеров в области.
* `MapControllerRoute`добавляет стандартный маршрут для контроллеров.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Удаление асинхронного суффикса из имен действий контроллера

В ASP.NET Core 3,0 ASP.NET Core MVC удаляет `Async` суффикс из имен действий контроллера. Это новое значение по умолчанию затрагивает маршрутизацию и создание ссылок. Например:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

До ASP.NET Core 3,0:

* Предыдущее действие можно было получить в маршруте *Products/ListAsync* .
* Требуется создание ссылки с указанием `Async` суффикса. Например:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

В ASP.NET Core 3,0:

* Предыдущее действие можно получить с помощью маршрута *Products/List* .
* Для создания канала не требуется указывать `Async` суффикс. Например:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Это изменение не влияет на имена, указанные с помощью [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) атрибута. Поведение по умолчанию можно отключить с помощью следующего кода в `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Изменения в поколении ссылок

Как описано в документации по [различиям между предыдущими версиями маршрутизации](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), существуют некоторые различия в создании ссылок ( `Url.Link` например, использование и аналогичные интерфейсы API). К ним относятся:

* По умолчанию при использовании маршрутизации конечных точек регистр параметров маршрута в созданных URI не обязательно сохраняется. Это поведение можно контролировать с помощью `IOutboundParameterTransformer` интерфейса.
* Создание URI для недопустимого маршрута (несуществующий контроллер, действие или страница) создаст пустую строку в разделе "Маршрутизация конечных точек" вместо создания недопустимого URI.
* Значения окружения (параметры маршрута из текущего контекста) не используются автоматически в создании ссылок с маршрутизацией конечных точек. Ранее при создании ссылки на другое действие (или страницу) неопределенные значения маршрута выводятся из значений окружающей среды *текущих* маршрутов. При использовании маршрутизации конечных точек все параметры маршрута должны быть заданы явным образом во время создания ссылки.

### <a name="no-locrazor-pages"></a>Razor Pages

RazorТеперь страницы сопоставления происходят внутри `UseEndpoints` .

Добавить `MapRazorPages` , если приложение использует Razor страницы. Так как маршрутизация конечных точек включает поддержку многих платформ, добавление Razor страниц теперь является явной.

В следующем `Startup.Configure` методе `MapRazorPages` добавляется поддержка Razor страниц:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Использовать MVC без маршрутизации конечных точек

Использование MVC с помощью `UseMvc` или `UseMvcWithDefaultRoute` в ASP.NET Core 3,0 требует явного согласия внутри `Startup.ConfigureServices` . Это необходимо, так как MVC должен определить, может ли он полагаться на по промежуточного слоя авторизации и CORS во время инициализации. Предоставляется анализатор, предупреждающий, попытается ли приложение использовать неподдерживаемую конфигурацию.

Если приложению требуется поддержка прежних версий `IRouter` , отключите `EnableEndpointRouting` их с помощью любого из следующих подходов в `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Проверки работоспособности

Проверки работоспособности можно использовать в качестве *маршрутизатора — вредоносные программы* с маршрутизацией конечных точек.

Добавьте `MapHealthChecks` , чтобы использовать проверки работоспособности с маршрутизацией конечных точек. `MapHealthChecks`Метод принимает аргументы, аналогичные `UseHealthChecks` . Преимущество использования функции `MapHealthChecks` over `UseHealthChecks` заключается в возможности применения авторизации и более точного контроля над политикой сопоставления.

В следующем примере `MapHealthChecks` метод вызывается для конечной точки проверки работоспособности `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>Хостбуилдер заменяет WebHostBuilder

Шаблоны ASP.NET Core 3,0 используют [универсальный узел](xref:fundamentals/host/generic-host). В предыдущих версиях использовался [веб-узел](xref:fundamentals/host/web-host). В следующем коде показан класс ASP.NET Core 3,0, созданный шаблоном `Program` :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

В следующем коде показан класс ASP.NET Core 2,2, созданный шаблоном `Program` :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>остается в 3,0 и является типом, `webBuilder` отображаемым в предыдущем примере кода. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>будет считаться устаревшим в будущих выпусках и заменено на `HostBuilder` .

Наиболее существенным изменением `WebHostBuilder` в `HostBuilder` является [внедрение зависимостей (DI)](xref:fundamentals/dependency-injection). При использовании `HostBuilder` можно внедрить только следующий `Startup` конструктор INTO:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder`Ограничения Di:

* Включите построение контейнера DI только один раз.
* Позволяет избежать итоговых проблем со временем существования объектов, таких как разрешение нескольких экземпляров Singleton.

Дополнительные сведения см. [в разделе Предотвращение введения в службу запуска в ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Аддаусоризатион перемещен в другую сборку

ASP.NET Core 2,2 и более низкие `AddAuthorization` методы в *Microsoft.AspNetCore.Authorization.dll*:

* Были переименованы `AddAuthorizationCore` .
* Были перемещены в *Microsoft.AspNetCore.Authorization.Policy.dll*.

Приложения, использующие как *Microsoft.AspNetCore.Authorization.dll* , так и *Microsoft.AspNetCore.Authorization.Policy.dll* , не затрагиваются.

Приложения, которые не используют *Microsoft.AspNetCore.Authorization.Policy.dll* , должны выполнять одно из следующих действий:

* Добавьте ссылку на *Microsoft.AspNetCore.Authorization.Policy.dll*. Этот подход работает для большинства приложений и является обязательным.
* Переключиться на использование`AddAuthorizationCore`

Дополнительные сведения см. [в разделе Перегрузка с критическим изменением `AddAuthorization(o =>` ) находится в другой #386 сборки](https://github.com/aspnet/Announcements/issues/386).

## <a name="no-locidentity-ui"></a>Пользовательский интерфейс Identity

IdentityОбновления пользовательского интерфейса для ASP.NET Core 3,0:

* Добавьте ссылку на пакет в [Microsoft. AspNetCore. Identity Пользовательский интерфейс](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Приложения, которые не используют Razor страницы, должны вызывать `MapRazorPages` . См. [ Razor страницы](#razor-pages) в этом документе.
* Начальная загрузка 4 является инфраструктурой пользовательского интерфейса по умолчанию. Задайте `IdentityUIFrameworkVersion` свойство проекта, чтобы изменить значение по умолчанию. Дополнительные сведения см. в [этом объявлении GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

SignalRКлиент JavaScript изменился с `@aspnet/signalr` на `@microsoft/signalr` . Чтобы реагировать на это изменение, измените ссылки в *package.jsдля* файлов, `require` инструкций и `import` инструкций ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Jsпо умолчанию является протоколом

`System.Text.Json`теперь является протоколом концентратора по умолчанию, используемым как клиентом, так и сервером.

В `Startup.ConfigureServices` вызовите, `AddJsonProtocol` чтобы задать параметры сериализатора.

**Сервером**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Компьютера**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chathub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Переключиться на Newtonsoft.Js

Если вы используете [функции Newtonsoft.Js, которые не поддерживаются в System.Text.Js](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), можно переключиться обратно на `Newtonsoft.Json` . См. статью [использование Newtonsoft.Json в SignalR проекте ASP.NET Core 3,0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) ранее в этой статье.

## <a name="redis-distributed-caches"></a>Redis распределенные кэши

Пакет [Microsoft. Extensions. Caching. Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) недоступен для приложений ASP.NET Core 3,0 и более поздних версий. Замените ссылку на пакет [Microsoft. Extensions. Caching. стаккексчанжередис](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Для получения дополнительной информации см. <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Согласие на компиляцию среды выполнения

До ASP.NET Core 3,0, компиляция представлений во время выполнения была неявной функцией платформы. Компиляция среды выполнения дополняет компиляцию представлений во время сборки. Она позволяет платформе компилировать Razor представления и страницы (файлы *. cshtml* ) при изменении файлов без необходимости перестроения всего приложения. Эта функция поддерживает сценарий выполнения быстрого редактирования в интегрированной среде разработки и обновления браузера для просмотра изменений.

В ASP.NET Core 3,0 компиляция среды выполнения является сценарием согласия. Компиляция во время сборки — единственный механизм для просмотра компиляции, включенный по умолчанию. Среда выполнения полагается на Visual Studio или [DotNet-Watch](xref:tutorials/dotnet-watch) в Visual Studio Code, чтобы перестроить проект, когда обнаруживает изменения в *CSHTML* -файлы. В Visual Studio изменения в файлах *CS*, *CSHTML*или *Razor* в выполняемом проекте (<kbd>CTRL + F5</kbd>), но не в режиме отладки (<kbd>F5</kbd>) активируют повторную компиляцию проекта.

Включение компиляции во время выполнения в проекте ASP.NET Core 3,0:

1. Установите [Microsoft. AspNetCore. MVC. Razor . ](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)Пакет NuGet рунтимекомпилатион.
1. Обновление `Startup.ConfigureServices` для вызова `AddRazorRuntimeCompilation` :

    Для ASP.NET Core MVC используйте следующий код:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Для ASP.NET Core Razor страниц используйте следующий код:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
В примере ниже https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation показан пример включения в средах разработки условной компиляции среды выполнения.

Дополнительные сведения о Razor компиляции файлов см. в разделе <xref:mvc/views/view-compilation> .

## <a name="migrate-libraries-via-multi-targeting"></a>Миграция библиотек через многоплатформенную нацеливание

Библиотекам часто требуется поддержка нескольких версий ASP.NET Core. Большинство библиотек, которые были скомпилированы в предыдущих версиях ASP.NET Core, должны продолжать работать без проблем. Для следующих условий требуется перекрестная компиляция приложения:

* Библиотека использует функцию с двоичным [критическим изменением](#breaking-api-changes).
* Библиотека хочет воспользоваться преимуществами новых функций в ASP.NET Core 3,0. 

Например:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Используйте `#ifdefs` , чтобы включить API-интерфейсы ASP.NET Core 3,0.

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Дополнительные сведения об использовании ASP.NET Core API в библиотеке классов см. в разделе <xref:fundamentals/target-aspnetcore> .

## <a name="miscellaneous-changes"></a>Прочие изменения

Система проверки в .NET Core 3.0 и более поздних версий рассматривает не допускающие значение NULL параметры или свойства привязки так, как если бы они имели атрибут `[Required]`. Дополнительные сведения см. в разделе [атрибут [Required]](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Публикация

Удалите папки *bin* и *obj* в каталоге проекта.

## <a name="testserver"></a>TestServer

Для приложений, непосредственно использующих <xref:Microsoft.AspNetCore.TestHost.TestServer> [универсальный узел](xref:fundamentals/host/web-host), создайте в `TestServer` <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Прерывание изменений API

Ознакомьтесь с критическими изменениями:

* [Полный список критических изменений в выпуске ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Прерывание изменений API в подделке, CORS, диагностике, MVC и маршрутизации](https://github.com/aspnet/Announcements/issues/387). Этот список содержит критические изменения для параметров совместимости.
* Сводные сведения о критических изменениях 2,2-3,0 в .NET Core, ASP.NET Core и Entity Framework Core см. в разделе [критические изменения для миграции с версии 2,2 на 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Маршрутизация конечных точек с параметром Catch-All

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 в службе приложений Azure

Развертывание .NET Core в службе приложений Azure завершено. Платформа .NET Core 3,0 доступна во всех центрах обработки данных службы приложений Azure.
