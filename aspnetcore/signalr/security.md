---
title: Вопросы безопасности в ASP.NET CoreSignalR
author: bradygaster
description: Узнайте, как использовать проверку подлинности и SignalRавторизацию в ASP.NET Core.
monikerRange: '>= aspnetcore-2.1'
ms.author: anurse
ms.custom: mvc
ms.date: 01/16/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: signalr/security
ms.openlocfilehash: 2b049d9d8131c6c95b2f768620c984d0f67f92cc
ms.sourcegitcommit: 70e5f982c218db82aa54aa8b8d96b377cfc7283f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2020
ms.locfileid: "82775327"
---
# <a name="security-considerations-in-aspnet-core-signalr"></a>Вопросы безопасности в ASP.NET CoreSignalR

[Эндрю Стантон-медперсонала](https://twitter.com/anurse)

В этой статье приводятся SignalRсведения о защите.

## <a name="cross-origin-resource-sharing"></a>Предоставление общего доступа к ресурсам независимо от источника

[Общий доступ к ресурсам между источниками (CORS)](https://www.w3.org/TR/cors/) можно использовать, чтобы разрешить подключения SignalR между источниками в браузере. Если код JavaScript размещается в другом домене из SignalR приложения, необходимо включить по [промежуточного слоя CORS](xref:security/cors) , чтобы разрешить JavaScript подключаться SignalR к приложению. Разрешать запросы между источниками только из доменов, которым вы доверяете или контролируете. Например:

* Ваш сайт размещен на`http://www.example.com`
* Ваше SignalR приложение размещено на`http://signalr.example.com`

CORS следует настроить в SignalR приложении, чтобы разрешить только источник. `www.example.com`

Дополнительные сведения о настройке CORS см. в разделе [Включение запросов между источниками (CORS)](xref:security/cors). SignalR**требуются** следующие политики CORS:

* Разрешить конкретные ожидаемые источники. Разрешение любого источника возможно, но **не** является безопасным или рекомендуемым.
* Методы `GET` HTTP и `POST` должны быть разрешены.
* Учетные данные должны быть разрешены для правильной работы прикрепленных сеансов на основе файлов cookie. Они должны быть включены, даже если проверка подлинности не используется.

::: moniker range=">= aspnetcore-5.0"

Однако в 5,0 мы предоставили в клиенте TypeScript возможность не использовать учетные данные.
Параметр не использовать учетные данные следует использовать только в том случае, если известно 100%, что учетные данные, такие как файлы cookie, не требуются в приложении (файлы cookie используются службой приложений Azure при использовании нескольких серверов для прикрепленных сеансов).

::: moniker-end

Например, следующая политика CORS позволяет клиенту SignalR , размещенному `https://example.com` в браузере, получать доступ к SignalR приложению, размещенному на `https://signalr.example.com`:

::: moniker range=">= aspnetcore-3.0"

```csharp
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    // ... other middleware ...

    // Make sure the CORS middleware is ahead of SignalR.
    app.UseCors(builder =>
    {
        builder.WithOrigins("https://example.com")
            .AllowAnyHeader()
            .WithMethods("GET", "POST")
            .AllowCredentials();
    });

    // ... other middleware ...
    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chatHub");
    });

    // ... other middleware ...
}
```

::: moniker-end

::: moniker range="<= aspnetcore-2.2"

[!code-csharp[Main](security/sample/Startup.cs?name=snippet1)]

::: moniker-end

## <a name="websocket-origin-restriction"></a>Ограничение источника WebSocket

::: moniker range=">= aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Ограничение [по источнику](xref:fundamentals/websockets#websocket-origin-restriction)для соединений WebSocket.

::: moniker-end

::: moniker range="< aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Браузеры **не** поддерживают следующие задачи:

* выполнение предварительных запросов CORS;
* использование ограничений, указанных в заголовках `Access-Control`, при выполнении запросов WebSocket.

Однако браузеры отправляют заголовок `Origin` при выпуске запросов WebSocket. Приложения должны быть настроены для проверки этих заголовков, чтобы использовались только WebSocket из ожидаемых источников.

В ASP.NET Core 2,1 и более поздних версиях проверка заголовков может быть достигнута с помощью пользовательского промежуточного слоя `Configure`, размещенного **до `UseSignalR`, и по промежуточного слоя** в:

[!code-csharp[Main](security/sample/Startup.cs?name=snippet2)]

> [!NOTE]
> Заголовок `Origin` контролируется клиентом и, как и заголовок `Referer`, может быть подделан. Эти заголовки **не** следует использовать в качестве механизма проверки подлинности.

::: moniker-end

## <a name="connectionid"></a>ConnectionId

Предоставление доступа `ConnectionId` может привести к злонамеренному олицетворению, SignalR если версия сервера или клиента ASP.NET Core 2,2 или более ранняя. Если версия SignalR сервера и клиента ASP.NET Core 3,0 или более поздней версии, `ConnectionToken` вместо `ConnectionId` необходимо хранить секретный код. `ConnectionToken` Цель не предоставляется ни в одном API.  Может быть трудно убедиться, что старые SignalR клиенты не подключаются к серверу, поэтому, даже если SignalR серверная версия ASP.NET Core 3,0 или более поздней `ConnectionId` версии, она не должна быть предоставлена.

## <a name="access-token-logging"></a>Ведение журнала маркеров доступа

При использовании веб-сокетов или событий, отправленных сервером, клиент браузера отправляет маркер доступа в строку запроса. Получение маркера доступа через строку запроса, как правило, безопасно с использованием `Authorization` стандартного заголовка. Всегда используйте протокол HTTPS, чтобы обеспечить безопасное сквозное подключение между клиентом и сервером. Многие веб-серверы заключают в журнал URL-адрес каждого запроса, включая строку запроса. Ведение журнала URL-адресов может регистрировать маркер доступа. ASP.NET Core записывает URL-адрес для каждого запроса по умолчанию, который будет включать строку запроса. Например:

```
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:5000/myhub?access_token=1234
```

Если у вас есть вопросы о записи этих данных в журналы сервера, можно полностью отключить это ведение журнала, настроив `Microsoft.AspNetCore.Hosting` средство ведения журнала `Warning` на уровень или выше (эти сообщения записываются на `Info` уровне). Дополнительные сведения см. в разделе [Фильтрация журналов](xref:fundamentals/logging/index#log-filtering) для получения дополнительных сведений. Если вы по-прежнему хотите заносить в журнал определенные сведения о запросе, можно [написать по промежуточного слоя](xref:fundamentals/middleware/write) для записи нужных `access_token` данных и отфильтровать значение строки запроса (при наличии).

## <a name="exceptions"></a>Исключения

Сообщения об исключениях обычно считаются конфиденциальными данными, которые не должны быть раскрыты для клиента. По умолчанию SignalR не отправляет сведения об исключении, созданном методом концентратора клиенту. Вместо этого клиент получает универсальное сообщение, указывающее на возникновение ошибки. Доставка сообщений об исключениях клиенту может быть переопределена (например, в разработке или тестировании) с помощью [енабледетаиледеррорс](xref:signalr/configuration#configure-server-options). Сообщения об исключениях не должны предоставляться клиенту в рабочих приложениях.

## <a name="buffer-management"></a>Управление буферами

SignalRиспользует буферы каждого подключения для управления входящими и исходящими сообщениями. По умолчанию SignalR ограничивает эти буферы до 32 КБ. Максимальное сообщение, которое клиент или сервер может отправить, — 32 КБ. Максимальный объем памяти, потребляемый соединением для сообщений, составляет 32 КБ. Если размер сообщений всегда меньше 32 КБ, можно уменьшить ограничение, которое:

* Запрещает клиенту отправить сообщение большего размера.
* Серверу не придется распределять большие буферы для приема сообщений.

Если размер сообщений превышает 32 КБ, можно увеличить это ограничение. Увеличение этого предела означает:

* Клиент может привести к выделению сервером больших буферов памяти.
* Выделение сервером больших буферов может сократить число одновременных подключений.

Существуют ограничения для входящих и исходящих сообщений. они могут быть настроены для объекта [хттпконнектиондиспатчероптионс](xref:signalr/configuration#configure-server-options) , настроенного в `MapHub`:

* `ApplicationMaxBufferSize`представляет максимальное число байтов от клиента, на котором находятся буферы сервера. Если клиент пытается отправить сообщение, размер которого превышает это ограничение, соединение может быть закрыто.
* `TransportMaxBufferSize`представляет максимальное число байтов, которое может быть отправлено сервером. Если сервер пытается отправить сообщение (включая возвращаемые значения из методов концентратора), превышающие это ограничение, будет создано исключение.

Установка ограничения `0` отключает ограничение. Удаление ограничения позволяет клиенту отправить сообщение любого размера. Вредоносные клиенты, отправляющие большие сообщения, могут вызвать чрезмерное выделение памяти. Чрезмерное использование памяти может значительно сократить количество одновременных подключений.
